#
# Generated by erpcgen 1.8.0 on Thu Oct 22 01:33:52 2020.
#
# AUTOGENERATED - DO NOT EDIT
#

import erpc

# Enumerators data types declarations
#@brief GAP Cause List
class RPC_T_GAP_CAUSE:
    RPC_GAP_CAUSE_SUCCESS = 0 #Operation success.
    RPC_GAP_CAUSE_ALREADY_IN_REQ = 1 #Operation already in progress.
    RPC_GAP_CAUSE_INVALID_STATE = 2 #Invalid state.
    RPC_GAP_CAUSE_INVALID_PARAM = 3 #Invalid parameter.
    RPC_GAP_CAUSE_NON_CONN = 4 #No connection establishment.
    RPC_GAP_CAUSE_NOT_FIND_IRK = 5 #IRK not found.
    RPC_GAP_CAUSE_ERROR_CREDITS = 6 #Credits error.
    RPC_GAP_CAUSE_SEND_REQ_FAILED = 7 #Send Request failed.
    RPC_GAP_CAUSE_NO_RESOURCE = 8 #No resource.
    RPC_GAP_CAUSE_INVALID_PDU_SIZE = 9 #Invalid PDU size.
    RPC_GAP_CAUSE_NOT_FIND = 10 #Not Found.
    RPC_GAP_CAUSE_CONN_LIMIT = 11 #Connection reachs limited count.
    RPC_GAP_CAUSE_NO_BOND = 12 #No Bond.
    RPC_GAP_CAUSE_ERROR_UNKNOWN = 255 #Unknown error.

class RPC_T_APP_RESULT:
    RPC_APP_RESULT_SUCCESS = 0
    RPC_APP_RESULT_PENDING = 3329
    RPC_APP_RESULT_ACCEPT = 3331
    RPC_APP_RESULT_REJECT = 3332
    RPC_APP_RESULT_NOT_RELEASE = 3333
    RPC_APP_RESULT_PREP_QUEUE_FULL = 1033
    RPC_APP_RESULT_INVALID_OFFSET = 1031
    RPC_APP_RESULT_INVALID_VALUE_SIZE = 1037
    RPC_APP_RESULT_INVALID_PDU = 1028
    RPC_APP_RESULT_ATTR_NOT_FOUND = 1034
    RPC_APP_RESULT_ATTR_NOT_LONG = 1035
    RPC_APP_RESULT_INSUFFICIENT_RESOURCES = 1041
    RPC_APP_RESULT_APP_ERR = 1152
    RPC_APP_RESULT_CCCD_IMPROPERLY_CONFIGURED = 1277
    RPC_APP_RESULT_PROC_ALREADY_IN_PROGRESS = 1278

#@brief LE advertising parameter types
class RPC_T_LE_ADV_PARAM_TYPE:
    RPC_GAP_PARAM_ADV_LOCAL_ADDR_TYPE = 608 #Advertisement used local bluetooth device address type. Read/Write Size is uint8.
    RPC_GAP_PARAM_ADV_DATA = 609 #Advertisement Data. Read/Write. Max size is uint8[GAP_MAX_ADV_LEN]. Default is "02:01:05", which means that it is a Limited Discoverable Advertisement.
    RPC_GAP_PARAM_SCAN_RSP_DATA = 610 #Scan Response Data. Read/Write. Max size is uint8[GAP_MAX_ADV_LEN]. Defaults to all 0.
    RPC_GAP_PARAM_ADV_EVENT_TYPE = 611 #Advertisement Type. Read/Write. Size is uint8.  Default is GAP_ADTYPE_ADV_IND (@ref T_GAP_ADTYPE).
    RPC_GAP_PARAM_ADV_DIRECT_ADDR_TYPE = 612 #Direct Advertisement Address Type. Read/Write. Size is uint8.
    RPC_GAP_PARAM_ADV_DIRECT_ADDR = 613 #Direct Advertisement Address. Read/Write. Size is uint8[GAP_BD_ADDR_LEN]. Default is NULL.
    RPC_GAP_PARAM_ADV_CHANNEL_MAP = 614 #Which channels to advertise on. Read/Write Size is uint8. Default is GAP_ADVCHAN_ALL (@ref ADV_CHANNEL_MAP)
    RPC_GAP_PARAM_ADV_FILTER_POLICY = 615 #Filter Policy. Ignored when directed advertising is used. Read/Write. Size is uint8. Default is GAP_ADV_FILTER_ANY (@ref T_GAP_ADV_FILTER_POLICY).
    RPC_GAP_PARAM_ADV_INTERVAL_MIN = 616 #Minimum advertising interval for undirected and low duty cycle directed advertising. Value range: 0x0020 - 0x4000 (20ms - 10240ms 0.625ms/step),Read/Write Size is uint16_t.
    RPC_GAP_PARAM_ADV_INTERVAL_MAX = 617 #Maximum advertising interval for undirected and low duty cycle directed  advertising. Value range: 0x0020 - 0x4000 (20ms - 10240ms 0.625ms/step)),Read/Write Size is uint16_t.

#@brief  GAP LE Parameter Types List.
class RPC_T_GAP_LE_PARAM_TYPE:
    RPC_GAP_PARAM_DEV_STATE = 544 #Device's current GAP device state. Read/Write. Size is sizeof(TGapDevState).
    RPC_GAP_PARAM_APPEARANCE = 545 #Local Device's Appearance. Read/Write. size is uint16. Appearance value please refer to GAP Appearance Values.(@ref GAP_LE_APPEARANCE_VALUES)
    RPC_GAP_PARAM_DEVICE_NAME = 546 #Local Device's Name. Write Only. Name string length is GAP_DEVICE_NAME_LEN.
    RPC_GAP_PARAM_SLAVE_INIT_GATT_MTU_REQ = 547 #Slave initiate the GATT exchange MTU procedure. Write Only.
    RPC_GAP_PARAM_RANDOM_ADDR = 548 #Random address. Write Only.
    RPC_GAP_PARAM_LATEST_CONN_BD_ADDR = 550 #Latest connected bluetooth devive address. Read Only.
    RPC_GAP_PARAM_LATEST_CONN_BD_ADDR_TYPE = 551 #Latest connected bluetooth devive address type. Read Only.
    RPC_GAP_PARAM_HANDLE_CREATE_CONN_IND = 552 #App handle the create connection indication message.
    RPC_GAP_PARAM_DEFAULT_PHYS_PREFER = 553 #Preferred values for the transmitter PHY and receiver PHY to be used for all subsequent connections over the LE transport.
    RPC_GAP_PARAM_DEFAULT_TX_PHYS_PREFER = 554 #The transmitter PHYs that the Host prefers the Controller to use.
    RPC_GAP_PARAM_DEFAULT_RX_PHYS_PREFER = 555 #The receiver PHYs that the Host prefers the Controller to use.
    RPC_GAP_PARAM_DEFAULT_DATA_LEN_MAX_TX_OCTETS = 558
    RPC_GAP_PARAM_DEFAULT_DATA_LEN_MAX_TX_TIME = 559
    RPC_GAP_PARAM_LOCAL_FEATURES = 560 #Local supported features.
    RPC_GAP_PARAM_DS_POOL_ID = 561 #Downstream PoolID.  Read only.  size is uint16.
    RPC_GAP_PARAM_DS_DATA_OFFSET = 562 #Downstream pool buffer data offset.  Read only.  size is uint16.
    RPC_GAP_PARAM_LE_REMAIN_CREDITS = 563 #Remain credits avaiable for TX.  Read only.  size is uint16.
    RPC_GAP_PARAM_MAX_WL_SIZE = 564 #Max white list size.  Read only.  size is uint16.

#@brief LE scan parameter type
class RPC_T_LE_SCAN_PARAM_TYPE:
    RPC_GAP_PARAM_SCAN_LOCAL_ADDR_TYPE = 576 #The type of address being used in the scan request packets. Read/Write.
    RPC_GAP_PARAM_SCAN_MODE = 577 #Scan mode. Read/Write. Size is uint8. Default is GAP_SCAN_MODE_ACTIVE (@ref T_GAP_SCAN_MODE).
    RPC_GAP_PARAM_SCAN_INTERVAL = 578 #Scan Interval. Read/Write. Size is uint16_t. Default is 0x10. Value range: 0x0004 - 0x4000 (2.5ms - 10240ms 0.625ms/step).
    RPC_GAP_PARAM_SCAN_WINDOW = 579 #Scan Window. Read/Write. Size is uint16_t. Default is 0x10. Value range: 0x0004 - 0x4000 (2.5ms - 10240ms 0.625ms/step).
    RPC_GAP_PARAM_SCAN_FILTER_POLICY = 580 #Scan Filter Policy.Read/Write. Size is uint8_t. Default is GAP_SCAN_FILTER_ANY (@ref T_GAP_SCAN_FILTER_POLICY).
    RPC_GAP_PARAM_SCAN_FILTER_DUPLICATES = 581 #Scan Filter Duplicates.Read/Write. Size is uint8_t. Default is GAP_SCAN_FILTER_DUPLICATE_DISABLE (@ref T_GAP_SCAN_FILTER_DUPLICATE).

#@brief  Definition of LE white list operation.
class RPC_T_GAP_WHITE_LIST_OP:
    RPC_GAP_WHITE_LIST_OP_CLEAR = 0 #Clear white list.
    RPC_GAP_WHITE_LIST_OP_ADD = 1 #Add a device to the white list.
    RPC_GAP_WHITE_LIST_OP_REMOVE = 2 #Remove a device from the white list.

#@brief GAP Remote Address Type
class RPC_T_GAP_REMOTE_ADDR_TYPE:
    RPC_GAP_REMOTE_ADDR_LE_PUBLIC = 0 #LE Public device address type.
    RPC_GAP_REMOTE_ADDR_LE_RANDOM = 1 #LE Random device address type.

#@brief Define random adress type
class RPC_T_GAP_RAND_ADDR_TYPE:
    RPC_GAP_RAND_ADDR_STATIC = 0 #Static random device address.
    RPC_GAP_RAND_ADDR_NON_RESOLVABLE = 1 #Non resolvable random device address.
    RPC_GAP_RAND_ADDR_RESOLVABLE = 2 #Resolvable random device address.

#@brief Define indentify address type
class RPC_T_GAP_IDENT_ADDR_TYPE:
    RPC_GAP_IDENT_ADDR_PUBLIC = 0
    RPC_GAP_IDENT_ADDR_RAND = 1

#@brief GAP gatt cccd not check.
class RPC_T_GAP_CONFIG_GATT_CCCD_NOT_CHECK:
    RPC_CONFIG_GATT_CCCD_CHECK = 0 #Check cccd when server sends notification or indication.
    RPC_CONFIG_GATT_CCCD_NOT_CHECK = 1 #Not check cccd when server sends notification or indication.

#@brief GAP Parameter List
class RPC_T_GAP_PARAM_TYPE:
    RPC_GAP_PARAM_BD_ADDR = 512 #Locol Device's Address. Read Only. Size is uint8[GAP_BD_ADDR_LEN]. This item is read from the controller.
    RPC_GAP_PARAM_BOND_PAIRING_MODE = 514 #Pairing Mode of LE and BR/EDR. Write Only. Size is uint8_t. Default is GAP_PAIRING_MODE_PAIRABLE (@ref BOND_PAIRING_MODE_DEFINES).
    RPC_GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS = 515 #Man-In-The-Middle (MITM) basically turns on Passkey protection in the pairing algorithm. Read/Write. Size is uint8_t. Default is GAP_AUTHEN_NO_MITM_YES_BOND (@ref BOND_MITM_DEFINES).
    RPC_GAP_PARAM_BOND_IO_CAPABILITIES = 516 #I/O capabilities.  Read/Write. Size is uint8_t. Default is GAP_IO_CAP_NO_INPUT_NO_OUTPUT (@ref T_GAP_IO_CAP).
    RPC_GAP_PARAM_BOND_OOB_ENABLED = 517 #OOB data available for pairing algorithm. Read/Write. Size is uint8_t. Default is 0(disabled).
    RPC_GAP_PARAM_BOND_LE_PAIRING_MODE = 519 #LE Pairing Mode. Read/Write. Size is uint8_t. Default is GAP_PAIRING_MODE_PAIRABLE (@ref BOND_PAIRING_MODE_DEFINES).

#@brief LE bond parameter types
class RPC_T_LE_BOND_PARAM_TYPE:
    RPC_GAP_PARAM_BOND_OOB_DATA = 528 #OOB Data. Read/Write. size uint8_t[16]. Default is all 0's.
    RPC_GAP_PARAM_BOND_FIXED_PASSKEY = 529 #The fix passcode for MITM protection. Read/Write. size is uint32_t. Range is 0 - 999,999. Default is 0.
    RPC_GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE = 530 #The fix passcode available for pairing. Read/Write. size is uint8_t. Default is 0(disabled).
    RPC_GAP_PARAM_BOND_SEC_REQ_ENABLE = 531 #Send smp security request when connected. Read/Write. size is uint8_t. Default is 0(disabled).
    RPC_GAP_PARAM_BOND_SEC_REQ_REQUIREMENT = 532 #Security request requirements. Read/Write. size is uint8_t. Default is GAP_AUTHEN_BIT_BONDING_FLAG (@ref BOND_MITM_DEFINES)
    RPC_GAP_PARAM_BOND_MIN_KEY_SIZE = 533 #Minium LTK size required. Read/Write. size is uint8_t.
    RPC_GAP_PARAM_BOND_KEY_MANAGER = 536 #Key manager. Write only. size is uint8_t. Default is 0(disabled).
    RPC_GAP_PARAM_BOND_SIGN_KEY_FLAG = 537 #Sign key flag configure. Write only. size is uint8_t. Default is 0(disabled).

#@brief  GAP Confirmation Cause List
class RPC_T_GAP_CFM_CAUSE:
    RPC_GAP_CFM_CAUSE_ACCEPT = 1 #Accept for indication, only used when confirmation.
    RPC_GAP_CFM_CAUSE_REJECT = 2 #Reject for indication, only used when confirmation.

#@brief Definition of security level.
class RPC_T_GAP_SEC_LEVEL:
    RPC_GAP_SEC_LEVEL_NO = 0 #No security (No authentication and no encryption).
    RPC_GAP_SEC_LEVEL_UNAUTHEN = 4 #Unauthenticated pairing with encryption.
    RPC_GAP_SEC_LEVEL_AUTHEN = 5 #Authenticated pairing with encryption.
    RPC_GAP_SEC_LEVEL_SC_UNAUTHEN = 7 #Unuthenticated LE Secure Connections pairing with encryption using a 128-bit strength encryption key.
    RPC_GAP_SEC_LEVEL_SC_AUTHEN = 8 #Authenticated LE Secure Connections pairing with encryption using a 128-bit strength encryption key.

#@brief LE connection parameter types
class RPC_T_LE_CONN_PARAM_TYPE:
    RPC_GAP_PARAM_CONN_BD_ADDR = 624 #Address of connected device. Read only. Size is uint8[B_MAX_ADV_LEN]. Set to all zeros when not connected.
    RPC_GAP_PARAM_CONN_BD_ADDR_TYPE = 625 #Address type of connected device. Read only. Size is uint8. Set to zero when not connected.
    RPC_GAP_PARAM_CONN_INTERVAL = 626 #Current connection interval.  Read only. Size is uint16.  Range is 7.5ms to 4 seconds (0x0006 to 0x0C80).  Default is 0 (no connection).
    RPC_GAP_PARAM_CONN_LATENCY = 627 #Current slave latency.  Read only.  Size is uint16.  Range is 0 to 499. Default is 0 (no slave latency or no connection).
    RPC_GAP_PARAM_CONN_TIMEOUT = 628 #Current timeout value.  Read only.  size is uint16.  Range is 100ms to 32 seconds.  Default is 0 (no connection).
    RPC_GAP_PARAM_CONN_MTU_SIZE = 629 #MTU size.  Read only.  size is uint16.
    RPC_GAP_PARAM_CONN_LOCAL_BD_TYPE = 630 #Local bluetooth address type.  Read only.  size is 1 byte.
    RPC_GAP_PARAM_CONN_RX_PHY_TYPE = 631 #Rx phy type.  Read only.  size is 1 byte.
    RPC_GAP_PARAM_CONN_TX_PHY_TYPE = 632 #Tx phy type.  Read only.  size is 1 byte.
    RPC_GAP_PARAM_CONN_REMOTE_FEATURES = 633 #Remote supported features.  Read only.
    RPC_GAP_PARAM_CONN_HANDLE = 635 #LE link connection handle. Read only.

#@brief GAP connection states
class RPC_T_GAP_CONN_STATE:
    RPC_GAP_CONN_STATE_DISCONNECTED = 0 #Disconnected.
    RPC_GAP_CONN_STATE_CONNECTING = 1 #Connecting.
    RPC_GAP_CONN_STATE_CONNECTED = 2 #Connected.
    RPC_GAP_CONN_STATE_DISCONNECTING = 3 #Disconnecting.

#@brief GAP link roles
class RPC_T_GAP_ROLE:
    RPC_GAP_LINK_ROLE_UNDEFINED = 0 #Unknown.
    RPC_GAP_LINK_ROLE_MASTER = 1 #Role is master.
    RPC_GAP_LINK_ROLE_SLAVE = 2 #Role is slave.

#@brief  Definition of LE Coded PHY preference options.
class RPC_T_GAP_PHYS_OPTIONS:
    RPC_GAP_PHYS_OPTIONS_CODED_PREFER_NO = 0 #Host has no preferred coding when transmitting on the LE Coded PHY
    RPC_GAP_PHYS_OPTIONS_CODED_PREFER_S2 = 1 #Host prefers that S=2 coding be used when transmitting on the LE Coded PHY
    RPC_GAP_PHYS_OPTIONS_CODED_PREFER_S8 = 2 #Host prefers that S=8 coding be used when transmitting on the LE Coded PHY

#@brief GAP connection phy types
class RPC_T_GAP_CONN_PARAM_TYPE:
    RPC_GAP_CONN_PARAM_1M = 0

#@brief LE Key Type
class RPC_T_LE_KEY_TYPE:
    RPC_LE_KEY_UNAUTHEN = 4 #SSP generated link key without MITM protection.
    RPC_LE_KEY_AUTHEN = 5 #SSP generated link key with MITM protection.
    RPC_LE_KEY_UNAUTHEN_P256 = 7 #Security Connections generated link key without MITM protection.
    RPC_LE_KEY_AUTHEN_P256 = 8 #Security Connections link key with MITM protection.

#@brief define local adress type
class RPC_T_GAP_LOCAL_ADDR_TYPE:
    RPC_GAP_LOCAL_ADDR_LE_PUBLIC = 0 #Bluetooth low energy public address.
    RPC_GAP_LOCAL_ADDR_LE_RANDOM = 1 #Bluetooth low energy random address.

#@brief  GATT write type
class RPC_T_GATT_WRITE_TYPE:
    RPC_GATT_WRITE_TYPE_REQ = 1 #ATT "Write Request"
    RPC_GATT_WRITE_TYPE_CMD = 2 #ATT "Write Command"
    RPC_GATT_WRITE_TYPE_SIGNED_CMD = 4 #ATT "Signed Write Command"

#@brief  GATT PDU type
class RPC_T_GATT_PDU_TYPE:
    RPC_GATT_PDU_TYPE_ANY = 0 #Any PDU type.
    RPC_GATT_PDU_TYPE_NOTIFICATION = 1 #Notification PDU type.
    RPC_GATT_PDU_TYPE_INDICATION = 2 #Indication PDU type.

#@brief Event type to inform app
class RPC_T_SERVICE_CALLBACK_TYPE:
    RPC_SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION = 1 #CCCD update event
    RPC_SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE = 2 #client read event
    RPC_SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE = 3 #client write event


# Structures data types declarations
#@brief  Connected device information.
class RPC_T_GAP_CONN_INFO(object):
    def __init__(self, conn_state=None, role=None, remote_bd=None, remote_bd_type=None):
        self.conn_state = conn_state # RPC_T_GAP_CONN_STATE
        self.role = role # RPC_T_GAP_ROLE
        self.remote_bd = remote_bd # uint8[6]

        self.remote_bd_type = remote_bd_type # uint8

    def _read(self, codec):
        self.conn_state = codec.read_uint32()
        self.role = codec.read_uint32()
        self.remote_bd = []
        for _i0 in range(6):
            _v0 = codec.read_uint8()
            self.remote_bd.append(_v0)

        self.remote_bd_type = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.conn_state is None:
            raise ValueError("conn_state is None")
        codec.write_uint32(self.conn_state)
        if self.role is None:
            raise ValueError("role is None")
        codec.write_uint32(self.role)
        if self.remote_bd is None:
            raise ValueError("remote_bd is None")
        for _i0 in self.remote_bd:
            codec.write_uint8(_i0)

        if self.remote_bd_type is None:
            raise ValueError("remote_bd_type is None")
        codec.write_uint8(self.remote_bd_type)

    def __str__(self):
        return "<%s@%x conn_state=%s role=%s remote_bd=%s remote_bd_type=%s>" % (self.__class__.__name__, id(self), self.conn_state, self.role, self.remote_bd, self.remote_bd_type)

    def __repr__(self):
        return self.__str__()
        
#@brief  Definition of LE connection request parameter.
class RPC_T_GAP_LE_CONN_REQ_PARAM(object):
    def __init__(self, scan_interval=None, scan_window=None, conn_interval_min=None, conn_interval_max=None, conn_latency=None, supv_tout=None, ce_len_min=None, ce_len_max=None):
        self.scan_interval = scan_interval # uint16
        self.scan_window = scan_window # uint16
        self.conn_interval_min = conn_interval_min # uint16
        self.conn_interval_max = conn_interval_max # uint16
        self.conn_latency = conn_latency # uint16
        self.supv_tout = supv_tout # uint16
        self.ce_len_min = ce_len_min # uint16
        self.ce_len_max = ce_len_max # uint16

    def _read(self, codec):
        self.scan_interval = codec.read_uint16()
        self.scan_window = codec.read_uint16()
        self.conn_interval_min = codec.read_uint16()
        self.conn_interval_max = codec.read_uint16()
        self.conn_latency = codec.read_uint16()
        self.supv_tout = codec.read_uint16()
        self.ce_len_min = codec.read_uint16()
        self.ce_len_max = codec.read_uint16()
        return self

    def _write(self, codec):
        if self.scan_interval is None:
            raise ValueError("scan_interval is None")
        codec.write_uint16(self.scan_interval)
        if self.scan_window is None:
            raise ValueError("scan_window is None")
        codec.write_uint16(self.scan_window)
        if self.conn_interval_min is None:
            raise ValueError("conn_interval_min is None")
        codec.write_uint16(self.conn_interval_min)
        if self.conn_interval_max is None:
            raise ValueError("conn_interval_max is None")
        codec.write_uint16(self.conn_interval_max)
        if self.conn_latency is None:
            raise ValueError("conn_latency is None")
        codec.write_uint16(self.conn_latency)
        if self.supv_tout is None:
            raise ValueError("supv_tout is None")
        codec.write_uint16(self.supv_tout)
        if self.ce_len_min is None:
            raise ValueError("ce_len_min is None")
        codec.write_uint16(self.ce_len_min)
        if self.ce_len_max is None:
            raise ValueError("ce_len_max is None")
        codec.write_uint16(self.ce_len_max)

    def __str__(self):
        return "<%s@%x scan_interval=%s scan_window=%s conn_interval_min=%s conn_interval_max=%s conn_latency=%s supv_tout=%s ce_len_min=%s ce_len_max=%s>" % (self.__class__.__name__, id(self), self.scan_interval, self.scan_window, self.conn_interval_min, self.conn_interval_max, self.conn_latency, self.supv_tout, self.ce_len_min, self.ce_len_max)

    def __repr__(self):
        return self.__str__()
        
#@brief Local Device Name
class RPC_T_LOCAL_NAME(object):
    def __init__(self, local_name=None):
        self.local_name = local_name # uint8[40]


    def _read(self, codec):
        self.local_name = []
        for _i0 in range(40):
            _v0 = codec.read_uint8()
            self.local_name.append(_v0)

        return self

    def _write(self, codec):
        if self.local_name is None:
            raise ValueError("local_name is None")
        for _i0 in self.local_name:
            codec.write_uint8(_i0)


    def __str__(self):
        return "<%s@%x local_name=%s>" % (self.__class__.__name__, id(self), self.local_name)

    def __repr__(self):
        return self.__str__()
        
#@brief Local Device Appearance
class RPC_T_LOCAL_APPEARANCE(object):
    def __init__(self, local_appearance=None, padding=None):
        self.local_appearance = local_appearance # uint16
        self.padding = padding # uint8[2]


    def _read(self, codec):
        self.local_appearance = codec.read_uint16()
        self.padding = []
        for _i0 in range(2):
            _v0 = codec.read_uint8()
            self.padding.append(_v0)

        return self

    def _write(self, codec):
        if self.local_appearance is None:
            raise ValueError("local_appearance is None")
        codec.write_uint16(self.local_appearance)
        if self.padding is None:
            raise ValueError("padding is None")
        for _i0 in self.padding:
            codec.write_uint8(_i0)


    def __str__(self):
        return "<%s@%x local_appearance=%s padding=%s>" % (self.__class__.__name__, id(self), self.local_appearance, self.padding)

    def __repr__(self):
        return self.__str__()
        
#@brief Remote Bluetooth device address info
class RPC_T_LE_REMOTE_BD(object):
    def __init__(self, addr=None, remote_bd_type=None, bond_flags=None):
        self.addr = addr # uint8[6]

        self.remote_bd_type = remote_bd_type # uint8
        self.bond_flags = bond_flags # uint8

    def _read(self, codec):
        self.addr = []
        for _i0 in range(6):
            _v0 = codec.read_uint8()
            self.addr.append(_v0)

        self.remote_bd_type = codec.read_uint8()
        self.bond_flags = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.addr is None:
            raise ValueError("addr is None")
        for _i0 in self.addr:
            codec.write_uint8(_i0)

        if self.remote_bd_type is None:
            raise ValueError("remote_bd_type is None")
        codec.write_uint8(self.remote_bd_type)
        if self.bond_flags is None:
            raise ValueError("bond_flags is None")
        codec.write_uint8(self.bond_flags)

    def __str__(self):
        return "<%s@%x addr=%s remote_bd_type=%s bond_flags=%s>" % (self.__class__.__name__, id(self), self.addr, self.remote_bd_type, self.bond_flags)

    def __repr__(self):
        return self.__str__()
        
#@brief LE key entry
class RPC_T_LE_KEY_ENTRY(object):
    def __init__(self, is_used=None, idx=None, flags=None, local_bd_type=None, app_data=None, reserved=None, remote_bd=None, resolved_remote_bd=None):
        self.is_used = is_used # bool
        self.idx = idx # uint8
        self.flags = flags # uint16
        self.local_bd_type = local_bd_type # uint8
        self.app_data = app_data # uint8
        self.reserved = reserved # uint8[2]

        self.remote_bd = remote_bd # RPC_T_LE_REMOTE_BD
        self.resolved_remote_bd = resolved_remote_bd # RPC_T_LE_REMOTE_BD

    def _read(self, codec):
        self.is_used = codec.read_bool()
        self.idx = codec.read_uint8()
        self.flags = codec.read_uint16()
        self.local_bd_type = codec.read_uint8()
        self.app_data = codec.read_uint8()
        self.reserved = []
        for _i0 in range(2):
            _v0 = codec.read_uint8()
            self.reserved.append(_v0)

        self.remote_bd = RPC_T_LE_REMOTE_BD()._read(codec)
        self.resolved_remote_bd = RPC_T_LE_REMOTE_BD()._read(codec)
        return self

    def _write(self, codec):
        if self.is_used is None:
            raise ValueError("is_used is None")
        codec.write_bool(self.is_used)
        if self.idx is None:
            raise ValueError("idx is None")
        codec.write_uint8(self.idx)
        if self.flags is None:
            raise ValueError("flags is None")
        codec.write_uint16(self.flags)
        if self.local_bd_type is None:
            raise ValueError("local_bd_type is None")
        codec.write_uint8(self.local_bd_type)
        if self.app_data is None:
            raise ValueError("app_data is None")
        codec.write_uint8(self.app_data)
        if self.reserved is None:
            raise ValueError("reserved is None")
        for _i0 in self.reserved:
            codec.write_uint8(_i0)

        if self.remote_bd is None:
            raise ValueError("remote_bd is None")
        self.remote_bd._write(codec)
        if self.resolved_remote_bd is None:
            raise ValueError("resolved_remote_bd is None")
        self.resolved_remote_bd._write(codec)

    def __str__(self):
        return "<%s@%x is_used=%s idx=%s flags=%s local_bd_type=%s app_data=%s reserved=%s remote_bd=%s resolved_remote_bd=%s>" % (self.__class__.__name__, id(self), self.is_used, self.idx, self.flags, self.local_bd_type, self.app_data, self.reserved, self.remote_bd, self.resolved_remote_bd)

    def __repr__(self):
        return self.__str__()
        
#@brief LE CCCD info
class RPC_T_LE_CCCD(object):
    def __init__(self, data_length=None, padding=None, data=None):
        self.data_length = data_length # uint8
        self.padding = padding # uint8[3]

        self.data = data # uint8

    def _read(self, codec):
        self.data_length = codec.read_uint8()
        self.padding = []
        for _i0 in range(3):
            _v0 = codec.read_uint8()
            self.padding.append(_v0)

        self.data = codec.read_uint8()
        return self

    def _write(self, codec):
        if self.data_length is None:
            raise ValueError("data_length is None")
        codec.write_uint8(self.data_length)
        if self.padding is None:
            raise ValueError("padding is None")
        for _i0 in self.padding:
            codec.write_uint8(_i0)

        if self.data is None:
            raise ValueError("data is None")
        codec.write_uint8(self.data)

    def __str__(self):
        return "<%s@%x data_length=%s padding=%s data=%s>" % (self.__class__.__name__, id(self), self.data_length, self.padding, self.data)

    def __repr__(self):
        return self.__str__()
        
